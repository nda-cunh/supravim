vim9script

#**** SUPRAVIM ****"
set nocompatible
filetype off

import autoload 'supraload.vim' as SupraLoad 
SupraLoad.Infect()

import autoload 'SupraMake.vim' as Make
import autoload 'SupraNotification.vim' as Notify
import autoload 'SupraPopup.vim' as Popup 
import autoload 'SupraUtils.vim' as Utils

g:sp_swap = false			# create swapfile (.swp)
g:sp_tree = true			# display folder tree at left
g:sp_fold = false			# add fold support 
g:sp_nobackground = false	# remove background color and use your terminal background
g:sp_wrap = true 			# do not wrap the text if the line is too long
g:sp_autoclose_quotes = true	# Auto Closing for quotes '"' and ''' and '`'
g:sp_autoclose_brackets = true # Auto Closing for brackets'(' ')' and '[' ']'
g:sp_autoclose_braces = false # Auto Closing for braces '{' '}'
g:sp_autoclose_angle = false # Auto Closing for angle brackets '<' '>'
g:sp_symbol_signs = "┃"	# The symbol used for the signs before it is this: ✖
g:sp_mapleader = "\<space>"	# The leader key used in the mappings
g:sp_theme = "onedark"

filetype plugin indent on
#--------------- jeu de couleur ---------------"
syntax on

if (has("termguicolors"))
	set termguicolors
endif

# Protect against invalid symbols
if true
	g:sp_symbol_signs = substitute(g:sp_symbol_signs, '\s+', '', 'g')
	const len = strcharlen(g:sp_symbol_signs)
	if len > 2
		call Notify.Notification(["Invalid symbol", "The symbol used for the signs must be a single character"], {type: 'error'})
		g:sp_symbol_signs = '✖'
	elseif len == 0
		call Notify.Notification(["Invalid symbol", "The symbol used for the signs must not be empty"], {type: 'error'})
		g:sp_symbol_signs = '✖'
	endif
endif

g:mapleader = g:sp_mapleader

set t_Co=256
exec 'colorscheme ' .. g:sp_theme
set background=dark

if g:sp_nobackground == true
	hi Normal guibg=NONE ctermbg=NONE
endif
#------------- Cursor Parts ------------"
&t_SI = "\<Esc>[5 q"
&t_SR = "\<Esc>[3 q"
&t_EI = "\<Esc>[2 q"
autocmd VimLeave * !echo -ne "\e[0 q"

#-------------- Save Undo  ------------"

set undodir=~/.cache/vim/undo
set undofile

# -------------  DBG integration  --------------"
packadd! termdebug
g:termdebug_wide = 1

#-------------- Auto Pairs ---------------------"
inoremap <silent><CR>	<CR><Plug>AutoPairsReturn

#--------------- Onglets ---------------------"
nnoremap <c-n>			<esc>:tabnew 
nnoremap <C-Right>		<scriptcmd>tabnext<CR>
nnoremap <C-Left>		<scriptcmd>tabprevious<CR>

#--------------- Racourcis --------------"
nnoremap <C-Up>		<scriptCmd>call Ctags()<CR>
nnoremap <C-Down>	<scriptcmd>pop<cr>
inoremap <C-Up>		<scriptcmd>call Ctags()<CR>
inoremap <C-Down>	<scriptcmd>pop<cr>
inoremap <c-q>		<cmd>q!<CR>
noremap <c-q>		<cmd>q!<CR>
inoremap <c-s>		<cmd>w!<CR><esc>
noremap <c-s>		<cmd>w!<CR><esc>
nnoremap <C-F5> 	<cmd>Termdebug -n <CR>
nnoremap <F2> 		<ScriptCmd>call Utils.RenameSymbol()<CR>
inoremap <F2> 		<ScriptCmd>call Utils.RenameSymbol()<CR>
nnoremap <leader>v		:vs<cr>
nnoremap <leader>s		:split<cr>
nnoremap <S-Right>	<C-w><Right>
nnoremap <S-Left>	<C-w><Left>
nnoremap <S-Up>		<C-w><Up>
nnoremap <S-Down>	<C-w><Down>
inoremap <TAB>		<TAB>
nnoremap <S-Tab>	<<
nnoremap <Tab>		>>
vnoremap <S-Tab>	<<<esc>gv
vnoremap <Tab>		>><esc>gv
inoremap <c-a>		<esc>gg<s-v>G
nnoremap <silent><c-@>		<cmd>LspHover<cr>
silent! unmap <c-t>
nnoremap <C-t>		<scriptcmd>term ++rows=15<CR>

# ---------------      LSP            ---------------"
set updatetime=500
autocmd CursorHold * call Utils.AutoLspHold()
#---------------      Command        ---------------"
cmap <c-q>	q!<cr>
cmap <c-s>	w!<cr>
cmap <c-v>	<c-r>0<del>

#---------------      Terminal        ---------------"
tnoremap <C-q> exit<CR>
tnoremap <F3> clear -x ; norminette<CR>
tnoremap <F5> supramake run<CR>
tnoremap <F6> supramake run2<CR>
tnoremap <F7> supramake run3<CR>
tnoremap <esc>	<c-\><c-n>

tnoremap <S-Right>		<C-W>N<C-w><Right>
tnoremap <S-Left>		<C-W>N<C-w><Left>
tnoremap <S-Up>			<C-W>N<C-w><Up>
tnoremap <S-Down>		<C-W>N<C-w><Down>

#--------------- utilitaires basiques ---------------"
g:lsp_log_verbose = 0
set mouse=a
if g:sp_swap == false
	set noswapfile
endif
if g:sp_wrap == true
	set wrap
else
	set nowrap
endif
set cursorline
set shortmess+=I
set nu
set incsearch
if executable('suprapack') == 0
	autocmd VimEnter * call Notify.Notification(["Suprapack is not found", "Please source the $HOME/.suprapack_profile", "Or add ~/.local/bin to your path"], {type: 'warning'})
	$PATH = $PATH .. ':' .. expand('$HOME') .. '/.local/bin:'
endif
set noautochdir
silent! exec 'cd ' .. expand('%:p:h')
silent! var project_root = system('suprabear -p')
var suprabear_return = v:shell_error
silent! exec 'chdir ' .. project_root
set title
set wildmenu
set tabstop=4
set shiftwidth=4
set smartindent
set autoindent
set shiftround
set showmode
set backspace=indent,eol,start
set pumheight=50
set notimeout
set ttimeout
set timeoutlen=100
set encoding=utf-8
set splitbelow
set splitright
au BufReadPost * if line("'\"") > 1 && line("'\"") <= line("$") | exe "normal! g'\"" | endif
set fillchars=vert:│
auto BufEnter,VimEnter *.tpp set filetype=cpp

#--------------- Lsp Interface ---------------"
def g:AddLspServer(name: string, cmd: list<string>, filetypes: list<string>)
	call lsp#register_server({
		\ name: name,
		\ cmd: (_) => cmd,
		\ allowlist: filetypes,
	\ })
	call lsp#activate()
enddef

#--------------- FONCTION ---------------"

def GotOutput(channel: channel, msg: string)
	# change_theme: [onehalf] <dark>
	if matchstr(msg, '^change_theme: ') != ''
		var theme = matchstr(msg, '\[\zs.*\ze\]')
		var typemode = matchstr(msg, '<\zs.*\ze>')
		call g:ChangeSupravimTheme(theme, typemode)
	# onChangeOption: [tree] <true>
	elseif matchstr(msg, '^onChangeOption: ') != ''
		var changed = matchstr(msg, '\[\zs.*\ze\]')
		var value = matchstr(msg, '<\zs.*\ze>')
		call g:ChangeSupravimOption(changed, value)
	endif
enddef

def g:ChangeSupravimTheme(theme: string, typemode: string)
	exec 'colorscheme ' .. theme
	exec 'set background=' .. typemode
	AirlineRefresh
	if g:sp_nobackground == true
		hi Normal guibg=NONE ctermbg=NONE
	endif
enddef

g:supravim_option_changed = 'null'
g:supravim_option_value = 'null'

def g:ChangeSupravimOption(changed: string, value: string)
	g:supravim_option_changed = changed
	g:supravim_option_value = value
	var text = 'g:sp_' .. g:supravim_option_changed .. ' = ' .. g:supravim_option_value
	execute text
	doautocmd User SupravimChangeOption
enddef

def SimpleSupravimChangeOption()
	if g:supravim_option_changed == 'tree'
		if g:supravim_option_value == 'false'
			SupraTreeClose
		else
			SupraTreeOpen
		endif
	elseif g:supravim_option_changed == 'swap'
		if g:supravim_option_value == 'false'
			set noswapfile
		else
			set swapfile
		endif
	elseif g:supravim_option_changed == 'fold'
		if g:supravim_option_value == 'false'
			set nofoldenable
		else
			set foldenable
		endif
	elseif g:supravim_option_changed == 'nobackground'
		if g:supravim_option_value == 'false'
			exec 'colorscheme ' .. g:sp_theme
			exec 'set background=' .. &background
			g:sp_nobackground = false
		else
			hi Normal guibg=NONE ctermbg=NONE
			g:sp_nobackground = true
		endif
	elseif g:supravim_option_changed == 'wrap'
		if g:supravim_option_value == 'false'
			set nowrap
		else
			set wrap
		endif
	endif
enddef

autocmd User SupravimChangeOption call SimpleSupravimChangeOption()

def g:SettingsSupravim()
	job_start(["supravim-gui"], {
		out_cb: GotOutput,
	})
enddef

if g:sp_fold == true
	auto BufEnter * call LoadBuf()
	def LoadBuf()
		var l = line('.')
		silent! loadview
		cursor(l, 1)
	enddef
endif

auto BufWritePost * call Save_post()
def Save_post()
	mkview
enddef

imap <C-F5>		<ScriptCmd>Gdbs<CR>
map <C-F5>		<ScriptCmd>Gdbs<CR>

command -nargs=0 -bar Gdbs :call Gdbf()

def Gdbf()
	if &filetype != 'c' && &filetype != 'cpp' && &filetype != 'vala' && &filetype != 'hpp'
		echo "Tu veux debugger quoi là ?"
	else
		set splitbelow nosplitbelow
		set splitright nosplitright
		SupraTreeClose
		if !filereadable("Makefile")
			exec ":Termdebug -n ./a.out"
		else
			exec ":Termdebug -n"
		endif
	endif
	set splitbelow
	set splitright
enddef
# -------------- Ctags ----------------"

command -nargs=0 -bar Ctags :call Ctags()

set tags=$HOME/.cache/tags

def Ctags()
	if suprabear_return == 0
		system("supratags --output=" .. expand("$HOME") .. "/.cache/tags")
		execute "tag " .. expand("<cword>")
	else
		LspDefinition
	endif
enddef

# ------ Running Supravim-Server ------"
def GotOutputSupravimServer(channel: channel, msg: string)
	if (stridx(msg, 'refresh') == 0)
		if Make.is_supramake == false
			doautocmd User RefreshTree
		endif
	elseif (stridx(msg, 'LoadBundle: ') == 0)
		var sp = split(msg, ' ')
		var bundle = sp[1] 
		var ft = sp[2]
		execute ("set filetype=" .. ft)
		var lst = glob($HOME .. "/.vim/bundle/" .. bundle .. '/**/*.vim', 0, 1)
		for file in lst
			if filereadable(file)
				exec 'source ' .. file
			endif
		endfor
	elseif (stridx(msg, 'LspGetServer') == 0)
		var sp = split(msg, '@#@')
		const cmds = split(sp[2], ',')
		const filetypes = split(sp[3], ',')
		g:AddLspServer(sp[1], cmds, filetypes)
	elseif (stridx(msg, 'LspServerError:') == 0)
		var new_msg = msg[15 : ]
		new_msg = substitute(new_msg, '\r', '\n', 'g')
		call Notify.Notification(["Error", new_msg], {type: 'error'})
	# Used to display the list of LSPs available for installation
	# format: LspInstall: <message>@#@<lsp1>[@#@<lsp2>...]@#@
	elseif (stridx(msg, 'LspInstall: ') == 0)
		var idx = stridx(msg, ': ')
		var new_msg = msg[idx + 2 : ]
		var sp = split(new_msg, '@#@')
		new_msg = substitute(sp[0], '\r', '\n', 'g')
		const items = sp[1 : ]
		var package_name = ''
		var items_copy = []
		for i in items
			if stridx(i, 'plugin-lang') != 0
				new_msg = new_msg .. "\n • " .. i
				add(items_copy, i)
			else
				package_name = i
			endif
		endfor
		call Notify.Notification(['SupraPack', new_msg], {type: 'package', left_click: (wid) => {
			if len(items_copy) == 0
				call GetChoice('', package_name)
			elseif len(items_copy) == 1
				call GetChoice(items_copy[0], package_name)
			else
				call OpenPopupChoice(items_copy, package_name)
			endif
			Notify.Close(wid)
		}})
	elseif (stridx(msg, 'FinishInstall') == 0)
		call FinishInstall(true)
	elseif (stridx(msg, 'InstallError') == 0)
		call FinishInstall(false, msg[14 : ])
	endif
enddef

var notification_timer: number
var notification_id: number

def FinishInstall(success: bool, error_text: string = '')
	# Vala is too speedy, so we need to wait a bit
	if notification_timer == 0
		timer_start(100, (_) => {
			FinishInstall(success, error_text)
		})
		return
	endif
	timer_stop(notification_timer)
	if success
		Notify.SetText(notification_id, ["Installation finished successfully!"])
		Notify.ChangeType(notification_id, 'success')
		timer_start(2000, (_) => {
			Notify.Close(notification_id)
			call lsp#activate()
		})
	else
		var error_msg = "Installation failed: " .. error_text
		error_msg = substitute(error_msg, '\r', '\n', 'g')
		Notify.SetText(notification_id, [error_msg])
		Notify.ChangeType(notification_id, 'error')
		timer_start(8000, (_) => {
			Notify.Close(notification_id)
		})
	endif
enddef

def GetChoice(choice: string, package_name: string = '')
	const loading = "⢿⣻⣽⣾⣷⣯⣟⡿"
	Notify.Notification([], {
		icon: '⮋',
		type: 'package',
		timeout: -1,
		left_click: (_) => {
		},
		cb_get_id: (wid) => {
			notification_id = wid
			var i = 0
			notification_timer = timer_start(100, (_) => {
				i = i + 1
				if i >= 8
					i = 0
				endif
				var text = " Installing: "
				if choice != ''
					text ..= choice .. " "
				endif
				if package_name != ''
					text ..= package_name .. " "
				endif
				Notify.SetText(notification_id, [loading[i] .. text])
			}, {'repeat': -1})
		},
	})
	var filetype = &filetype
	if filetype == ''
		filetype = expand('%:e')
	endif

	var c1: string
	var c2: string
	if package_name == ''
		c2 = 'null'
	else
		c2 = package_name
	endif
	if choice == ''
		c1 = 'null'
	else
		c1 = choice
	endif
	ch_sendraw(supravim_server, "Install: " .. c1 .. " " .. c2 .. "\n")
enddef

def OpenPopupChoice(items: list<string>, package_name: string = '')
	var width = 50
	const title = '─ Which Lsp to choose? '
	var popup = popup_create([], {
		title: repeat('─', (width / 2) - (len(title) / 2) + 2) .. ' Which Lsp to choose? ',
		minwidth: 50,
		minheight: 5,
		tabpage: -1,
		borderhighlight: ['Normal', 'Normal', 'Normal', 'Normal'],
		borderchars: ['─', '│', '─', '│', '╭', '╮', '╯', '╰'],
		highlight: 'Normal',
		border: [1],
		padding: [0, 1, 0, 1],
		cursorline: 1,
		mapping: false,
		callback: (wid, data) => {
			if data == []
				return
			endif
			call GetChoice(data[0], package_name)
		},
		filter: (wid: number, key: string) => {
			var bufnr = winbufnr(wid)
			var cursorlinepos = line('.', wid)
			if key == "\<Esc>"
				popup_close(wid)
				return 0
			elseif key == "\<Up>"
				win_execute(wid, 'norm! k')
			elseif key == "\<Down>"
				win_execute(wid, 'norm! j')
			elseif key ==? "\<LeftMouse>"
				var pos = getmousepos()
				if pos.winid != wid
					return 0
				endif
				win_execute(wid, 'norm! ' .. pos.line .. 'G')
			elseif key ==? "\<2-LeftMouse>"
				var pos = getmousepos()
				if pos.winid != wid
					return 0
				endif
				win_execute(wid, 'norm! ' .. pos.line .. 'G')
				var linetext = getbufline(bufnr, pos.line, pos.line)[0]
				if linetext == ''
					popup_close(wid)
				else
					popup_close(wid, [linetext])
				endif
			elseif key == "\<CR>"
				var linetext = getbufline(bufnr, cursorlinepos, cursorlinepos)[0]
				if linetext == ''
					popup_close(wid)
				else
					popup_close(wid, [linetext])
				endif
			else
				return 0
			endif
			return 1
		},
	}
	)
	popup_settext(popup, items)
enddef

var supravim_server = job_start(["supravim-server", project_root], {
	out_cb: GotOutputSupravimServer,
	in_mode: 'raw',
	in_io: 'pipe'
})

def OpenNewFile()
	var filetype = &filetype
	if filetype == ''
		filetype = expand('%:e')
	endif
	ch_sendraw(supravim_server, "OpenFile: " .. filetype .. "\n")
enddef

au BufEnter * OpenNewFile()

# ----------------- AIR LINE ------------------"
g:airline#extensions#whitespace#enabled = 0
g:airline_section_z = airline#section#create(['Line:%l', 'hunks', ' Col:%c'])
g:airline_section_b = airline#section#create(['SupraVim'])
g:airline_left_sep = '◤'
g:airline_left_alt_sep = '╱'
g:airline_right_sep = '◥'
g:airline_right_alt_sep = '╲'
g:airline#extensions#tabline#enabled = 1
g:airline#extensions#tabline#show_buffers = 0
g:airline#extensions#tabline#tabs_label = 'Tabs'
g:airline#extensions#tabline#buffer_nr_show = 0
g:airline#extensions#tabline#tab_nr_type = 1
g:airline#extensions#tabline#left_sep = '◤'
g:airline#extensions#tabline#left_alt_sep = '╱'
g:airline#extensions#tabline#right_sep = '◥'
g:airline#extensions#tabline#right_alt_sep = '╱'

# ----------------- POPUP ------------------ #
autocmd VimEnter * CreatePopit()

def PopUpUpdate(channel: channel, msg: string)
	Notify.Notification(["Update", msg, "run: `suprapack update`", "Click here to update"], {
		left_click: (_) => {
			!suprapack update
		},
		icon: '󰚰'
	})
enddef

def CreatePopit()
	job_start(["suprapack", "have_update", "supravim"], {
		out_cb: PopUpUpdate,
	})
enddef

# -----------------   Alt Up/Down   ------------------ #
vnoremap <silent> <A-Down>	:<scriptcmd>Utils.MoveLineDown("v")<CR><cr>
vnoremap <silent> <A-Up>	:<scriptcmd>Utils.MoveLineUp("v")<CR><cr>
nnoremap <silent> <A-Down>	<scriptcmd>Utils.MoveLineDown("n")<CR>
nnoremap <silent> <A-Up>	<scriptcmd>Utils.MoveLineUp("n")<CR>

# Fuzzy Finder
nnoremap <silent> <leader>g			<scriptcmd>FuzzyGrep<CR>
nnoremap <silent> <leader>f			<scriptcmd>FuzzyFiles<CR>
nnoremap <silent> <leader>b			<scriptcmd>FuzzyBuffers<CR>
nnoremap <silent> <leader>h			<scriptcmd>FuzzyHighlights<CR>
nnoremap <silent> <leader>c			<scriptcmd>FuzzyClip<cr>
nnoremap <silent> <leader><f5>		<scriptcmd>FuzzyMake<cr>
nnoremap <silent> <leader><f5>		<scriptcmd>FuzzyHarpoon<cr>
nnoremap <silent> <leader>t			<scriptcmd>FuzzySupraTags<cr>
nnoremap <silent> <leader><leader>	<scriptcmd>FuzzyBuffers<CR>

g:fuzzbox_enable_mappings = 0
g:fuzzbox_files_exclude_file = ['*.o', '*.png', '*.jpg', '*.gif', 'compile_commands.json', '*.beam', '*.so', '*.exe', '*.dll', '*.dump', '*.core', '*.swn', '*.swp', '*.a', '*.out']
g:fuzzbox_files_exclude_dir = ['build', '*.cache', '.git', '.hg', '.svn', '.rebar', '.eunit']


# SupraVim Settings Sync
inoremap <F12>	<scriptcmd>call SettingsSupravim()<cr>
noremap <F12>	<scriptcmd>call SettingsSupravim()<cr>

nnoremap <RightMouse> <esc><LeftMouse><esc><RightMouse>
inoremap <RightMouse> <esc><LeftMouse><esc><RightMouse>
nnoremap <c-leftmouse>	<leftmouse><scriptcmd>call Ctags()<cr>

# Round It --------------------------------------
def RoundIt(char: string, charend: string)
	const p1 = getpos("'<")
	const p2 = getpos("'>")
	call cursor(p1[1], p1[2])
	execute('normal! i' .. char)
	call cursor(p2[1], p2[2] + 1)
	execute('normal! a' .. charend)
enddef

if g:sp_autoclose_quotes
	vnoremap "		<esc><scriptcmd>RoundIt('"', '"')<CR>
	snoremap "		""<left>
	vnoremap '		<esc><scriptcmd>RoundIt("'", "'")<CR>
	snoremap '		''<left>
	vnoremap `		<esc><scriptcmd>RoundIt('`', '`')<CR>
	snoremap `		``<left>
endif
if g:sp_autoclose_brackets
	vnoremap (		<esc><scriptcmd>RoundIt('(', ')')<CR>
	vnoremap [		<esc><scriptcmd>RoundIt('[', ']')<CR>
	snoremap (		()<left>
	snoremap [		[]<left>
endif
if g:sp_autoclose_braces
	vnoremap {		<esc><scriptcmd>RoundIt('{', '}')<CR>
	snoremap {		{}<left>
endif
if g:sp_autoclose_angle
	vnoremap <		<esc><scriptcmd>RoundIt('<', '>')<CR>
	snoremap <		<><left>
endif

# Popup Menu --------------------------------------

set mousemodel=popup
autocmd BufEnter * call Init_menu()
def Init_menu()
	vmenu PopUp.Copy			y
	vmenu PopUp.Cut				d
	vmenu PopUp.Paste			p
	vmenu PopUp.Select\ All		<esc>gg<s-v>G
	if g:sp_fold
		vmenu PopUp.Fold			zf
	endif
	vmenu PopUp.Equalize		=
	vmenu PopUp.-sep4- <Nop>

	nmenu PopUp.Show\ References	<esc>:LspReferences<cr>
	nmenu PopUp.-sep5- <Nop>
	nmenu PopUp.Save\ All		:wall<CR>
	nmenu PopUp.Auto\ Norm		<leader><F2>
	nmenu PopUp.Switch\ Norm		<F3>
	nmenu PopUp.-sep0- <Nop>
	nmenu PopUp.Select\ All		<esc>gg<s-v>G
	nmenu PopUp.Paste			p
	nmenu PopUp.Undo			u
	nmenu PopUp.Redo			<C-r>
	nmenu PopUp.-sep2- <Nop>
	nmenu PopUp.Debug			:call Gdbf()<cr>
	nmenu PopUp.Rename\ Symbol <F2>	

	if g:sp_fold
		nmenu PopUp.-sep3- <Nop>
		nmenu PopUp.Fold			<scriptcmd>Fold()<CR>
		nmenu PopUp.UnFold			zo
		nmenu PopUp.Fold\ All		<scriptcmd>FoldAll()<CR>
		nmenu PopUp.UnFold\ All		zR
	endif
	nmenu PopUp.-sep4- <Nop>
	nmenu PopUp.SupraVim\ Settings :call SettingsSupravim()<CR>
enddef

# Fold support --------------------------------------

if g:sp_fold == true
	def Fold()
		set foldmethod=syntax
		execute "normal! zc"
		set foldmethod=manual
	enddef

	def FoldAll()
		set foldmethod=syntax
		execute "normal! zM"
		set foldmethod=manual
	enddef
endif


# SetArgv --------------------------------------
command -nargs=* -complete=file SetArgv :call SetArgv(<f-args>)
command -nargs=* -complete=file SetArgs :call SetArgv(<f-args>)

def SetArgv(...args: list<string>)
	var str = join(args, ' ')
	$ARGS = str
enddef

# Welcome --------------------------------------

autocmd BufEnter * {
	if expand('%:e') == 'water'
		&titlestring = '[Supravim] Editing on SupraWater'
	else
		&titlestring = '[Supravim]  ' .. expand('%:t')
	endif
}

g:loaded_netrw = 1
g:loaded_netrwPlugin = 1

def Welcome()
	# Used for SupraWater with folder
	silent! autocmd! FileExplorer
	var timer = timer_start(50, (_) => {
		echo 'Welcome to SupraVim ! Press <F12> for help'
	})
	if g:sp_fold
		set foldmethod=manual
	endif
enddef

import autoload 'Welcome.vim' as Wel 

if argc() == 0
	Wel.SupraWelcome()
endif

# Force directory creation on save
autocmd BufWritePre * {
if filereadable(expand('%')) == 0
	mkdir(expand('%:p:h'), 'p')
endif
}

autocmd VimEnter * call Welcome()

#--------------- SupraTree ---------------"
g:SupraTreeIgnoreTree = ['\.png$\', '\.jpg$', '\.o$']
g:SupraTreeWinSize = 27
g:SupraTreeOpenByDefault = g:sp_tree
nnoremap <c-g> <cmd>SupraTreeToggle<cr> 

#--------------- SupraVim Color ----------"
def FixSupraVimColor()
	hi! link SignColumn Normal
	hi! link EndOfBuffer Normal
enddef
autocmd Colorscheme * call FixSupraVimColor()
FixSupraVimColor()
